#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <Accelerate/Accelerate.h>
#include <cairo.h>

/* Safe malloc */
void *xmalloc(size_t s) {
    void *p = malloc(s);
    if (!p) { printf("Out of memory!\n"); exit(1); }
    return p;
}

/* Read data file generated by Python */
int read_data(const char *filename, int *order, int *N,
              double **x, double **y_noisy, double **y_true)
{
    FILE *f = fopen(filename, "r");
    if (!f) {
        printf("Error: cannot open file %s\n", filename);
        return -1;
    }

    char line[512];

    /* Parse header */
    if (!fgets(line, sizeof(line), f)) return -1;
    sscanf(line, "Polynomial order: %d", order);

    if (!fgets(line, sizeof(line), f)) return -1;
    sscanf(line, "Number of data points: %d", N);

    /* Skip header row */
    fgets(line, sizeof(line), f);

    *x       = xmalloc(sizeof(double) * (*N));
    *y_noisy = xmalloc(sizeof(double) * (*N));
    *y_true  = xmalloc(sizeof(double) * (*N));

    for (int i = 0; i < *N; i++) {
        double xv, yn, yt;
        if (!fgets(line, sizeof(line), f)) {
            printf("Unexpected EOF at line %d\n", i);
            return -1;
        }

        if (sscanf(line, "%lf %lf %lf", &xv, &yn, &yt) != 3) {
            printf("Bad data line: %s\n", line);
            return -1;
        }

        (*x)[i] = xv;
        (*y_noisy)[i] = yn;
        (*y_true)[i] = yt;
    }

    fclose(f);
    return 0;
}

/* Build Vandermonde matrix (column-major for BLAS) */
void build_vandermonde(int N, int deg, const double *x, double *X)
{
    int P = deg + 1;
    for (int j = 0; j < P; j++) {
        int power = deg - j;
        for (int i = 0; i < N; i++) {
            X[j*N + i] = pow(x[i], power);
        }
    }
}

/* Draw data using Cairo */
void draw_plot_png(double *x, double *y_noisy, double *y_true, int N)
{
    int W = 800, H = 600;

    cairo_surface_t *surface =
        cairo_image_surface_create(CAIRO_FORMAT_ARGB32, W, H);
    cairo_t *cr = cairo_create(surface);

    // Background white
    cairo_set_source_rgb(cr, 1, 1, 1);
    cairo_paint(cr);

    // Scale to fit data
    double xmin = x[0], xmax = x[N-1];

    double ymin = y_noisy[0], ymax = y_noisy[0];
    for (int i = 1; i < N; i++) {
        if (y_noisy[i] < ymin) ymin = y_noisy[i];
        if (y_noisy[i] > ymax) ymax = y_noisy[i];
        if (y_true[i] < ymin) ymin = y_true[i];
        if (y_true[i] > ymax) ymax = y_true[i];
    }

    double margin = 50;
    double sx = (W - 2*margin) / (xmax - xmin);
    double sy = (H - 2*margin) / (ymax - ymin);

    // Draw axes
    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_set_line_width(cr, 2);

    cairo_move_to(cr, margin, H - margin);
    cairo_line_to(cr, W - margin, H - margin);
    cairo_stroke(cr);

    cairo_move_to(cr, margin, margin);
    cairo_line_to(cr, margin, H - margin);
    cairo_stroke(cr);

    // Plot noisy data (red)
    cairo_set_source_rgb(cr, 1, 0, 0);
    cairo_set_line_width(cr, 2);

    for (int i = 0; i < N; i++) {
        double px = margin + (x[i] - xmin) * sx;
        double py = H - margin - (y_noisy[i] - ymin) * sy;

        cairo_arc(cr, px, py, 2.5, 0, 2 * M_PI);
        cairo_fill(cr);
    }

    // Plot true data (blue line)
    cairo_set_source_rgb(cr, 0, 0, 1);
    cairo_set_line_width(cr, 2);

    for (int i = 0; i < N; i++) {
        double px = margin + (x[i] - xmin) * sx;
        double py = H - margin - (y_true[i] - ymin) * sy;

        if (i == 0)
            cairo_move_to(cr, px, py);
        else
            cairo_line_to(cr, px, py);
    }
    cairo_stroke(cr);

    cairo_surface_write_to_png(surface, "plot.png");

    cairo_destroy(cr);
    cairo_surface_destroy(surface);

    printf("\nPNG plot saved as: plot.png\n");
}


int main(int argc, char **argv)
{
    const char *infile = "synthetic_polynomial_data.txt";
    if (argc > 1) infile = argv[1];

    int N, deg;
    double *x, *y_noisy, *y_true;

    printf("Reading: %s\n", infile);

    if (read_data(infile, &deg, &N, &x, &y_noisy, &y_true) != 0) {
        printf("File read error.\n");
        return 1;
    }

    printf("Loaded %d points, degree = %d\n", N, deg);

    int P = deg + 1;

    double *X   = xmalloc(sizeof(double) * N * P);
    double *XtX = xmalloc(sizeof(double) * P * P);
    double *Xty = xmalloc(sizeof(double) * P);

    build_vandermonde(N, deg, x, X);

    /* XtX = X^T X */
    cblas_dgemm(CblasColMajor, CblasTrans, CblasNoTrans,
                P, P, N, 1.0,
                X, N, X, N,
                0.0, XtX, P);

    /* Xty = X^T y */
    cblas_dgemv(CblasColMajor, CblasTrans,
                N, P, 1.0,
                X, N, y_noisy, 1,
                0.0, Xty, 1);

    /* Solve (XtX) beta = Xty */
    int n = P, nrhs = 1, lda = P, ldb = P, info;
    char uplo = 'U';

    dposv_(&uplo, &n, &nrhs, XtX, &lda, Xty, &ldb, &info);

    if (info != 0) {
        printf("Error: dposv failed with info=%d\n", info);
        return 1;
    }

    printf("\nOptimal Polynomial Coefficients:\n");
    for (int i = 0; i < P; i++) {
        printf("c[%d] = %.12f\n", i, Xty[i]);
    }

    // Draw PNG using Cairo
    draw_plot_png(x, y_noisy, y_true, N);
    return 0;
}